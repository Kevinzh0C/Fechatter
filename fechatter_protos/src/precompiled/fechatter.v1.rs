// This file is @generated by prost-build.
/// 用户信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(string, tag = "2")]
    pub fullname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
    #[prost(enumeration = "UserStatus", tag = "4")]
    pub status: i32,
    #[prost(int64, tag = "5")]
    pub workspace_id: i64,
    #[prost(bool, tag = "6")]
    pub is_bot: bool,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 工作空间
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workspace {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub owner_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 聊天信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chat {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ChatType", tag = "3")]
    pub r#type: i32,
    #[prost(int64, tag = "4")]
    pub workspace_id: i64,
    #[prost(int64, repeated, tag = "5")]
    pub members: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 消息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(int64, tag = "2")]
    pub chat_id: i64,
    #[prost(int64, tag = "3")]
    pub sender_id: i64,
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 文件信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub size: i64,
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub uploaded_by: i64,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 分页参数
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Pagination {
    #[prost(int32, tag = "1")]
    pub page: i32,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
}
/// 分页响应
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PaginatedResponse {
    #[prost(int32, tag = "1")]
    pub total: i32,
    #[prost(int32, tag = "2")]
    pub page: i32,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(int32, tag = "4")]
    pub total_pages: i32,
}
/// 错误信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// 用户状态
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserStatus {
    Unspecified = 0,
    Active = 1,
    Inactive = 2,
    Banned = 3,
}
impl UserStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "USER_STATUS_UNSPECIFIED",
            Self::Active => "USER_STATUS_ACTIVE",
            Self::Inactive => "USER_STATUS_INACTIVE",
            Self::Banned => "USER_STATUS_BANNED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_STATUS_ACTIVE" => Some(Self::Active),
            "USER_STATUS_INACTIVE" => Some(Self::Inactive),
            "USER_STATUS_BANNED" => Some(Self::Banned),
            _ => None,
        }
    }
}
/// 聊天类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatType {
    Unspecified = 0,
    /// 单人聊天
    Single = 1,
    /// 群组聊天
    Group = 2,
    /// 频道
    Channel = 3,
}
impl ChatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CHAT_TYPE_UNSPECIFIED",
            Self::Single => "CHAT_TYPE_SINGLE",
            Self::Group => "CHAT_TYPE_GROUP",
            Self::Channel => "CHAT_TYPE_CHANNEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CHAT_TYPE_SINGLE" => Some(Self::Single),
            "CHAT_TYPE_GROUP" => Some(Self::Group),
            "CHAT_TYPE_CHANNEL" => Some(Self::Channel),
            _ => None,
        }
    }
}
/// 分析事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyticsEvent {
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<EventContext>,
    #[prost(
        oneof = "analytics_event::EventType",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25"
    )]
    pub event_type: ::core::option::Option<analytics_event::EventType>,
}
/// Nested message and enum types in `AnalyticsEvent`.
pub mod analytics_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EventType {
        #[prost(message, tag = "10")]
        AppStart(super::AppStartEvent),
        #[prost(message, tag = "11")]
        AppExit(super::AppExitEvent),
        #[prost(message, tag = "12")]
        UserLogin(super::UserLoginEvent),
        #[prost(message, tag = "13")]
        UserLogout(super::UserLogoutEvent),
        #[prost(message, tag = "14")]
        UserRegister(super::UserRegisterEvent),
        #[prost(message, tag = "15")]
        ChatCreated(super::ChatCreatedEvent),
        #[prost(message, tag = "16")]
        MessageSent(super::MessageSentEvent),
        #[prost(message, tag = "17")]
        ChatJoined(super::ChatJoinedEvent),
        #[prost(message, tag = "18")]
        ChatLeft(super::ChatLeftEvent),
        #[prost(message, tag = "19")]
        Navigation(super::NavigationEvent),
        #[prost(message, tag = "20")]
        FileUploaded(super::FileUploadedEvent),
        #[prost(message, tag = "21")]
        FileDownloaded(super::FileDownloadedEvent),
        #[prost(message, tag = "22")]
        SearchPerformed(super::SearchPerformedEvent),
        #[prost(message, tag = "23")]
        NotificationReceived(super::NotificationReceivedEvent),
        #[prost(message, tag = "24")]
        ErrorOccurred(super::ErrorOccurredEvent),
        #[prost(message, tag = "25")]
        BotResponse(super::BotResponseEvent),
    }
}
/// 事件上下文
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventContext {
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub app_version: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub client_ts: i64,
    #[prost(int64, tag = "6")]
    pub server_ts: i64,
    #[prost(string, tag = "7")]
    pub user_agent: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub ip: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub system: ::core::option::Option<SystemInfo>,
    #[prost(message, optional, tag = "10")]
    pub geo: ::core::option::Option<GeoLocation>,
}
/// 系统信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemInfo {
    #[prost(string, tag = "1")]
    pub os: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub arch: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub locale: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub timezone: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub browser: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub browser_version: ::prost::alloc::string::String,
}
/// 地理位置
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoLocation {
    #[prost(string, tag = "1")]
    pub country: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub city: ::prost::alloc::string::String,
}
/// 应用启动事件
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppStartEvent {}
/// 应用退出事件
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppExitEvent {
    #[prost(enumeration = "app_exit_event::ExitCode", tag = "1")]
    pub exit_code: i32,
}
/// Nested message and enum types in `AppExitEvent`.
pub mod app_exit_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExitCode {
        Unspecified = 0,
        Success = 1,
        Error = 2,
        Crash = 3,
    }
    impl ExitCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXIT_CODE_UNSPECIFIED",
                Self::Success => "EXIT_CODE_SUCCESS",
                Self::Error => "EXIT_CODE_ERROR",
                Self::Crash => "EXIT_CODE_CRASH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXIT_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "EXIT_CODE_SUCCESS" => Some(Self::Success),
                "EXIT_CODE_ERROR" => Some(Self::Error),
                "EXIT_CODE_CRASH" => Some(Self::Crash),
                _ => None,
            }
        }
    }
}
/// 用户登录事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserLoginEvent {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    /// password, oauth, etc.
    #[prost(string, tag = "2")]
    pub login_method: ::prost::alloc::string::String,
}
/// 用户登出事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserLogoutEvent {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// 用户注册事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserRegisterEvent {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workspace_id: ::prost::alloc::string::String,
    /// email, oauth, etc.
    #[prost(string, tag = "3")]
    pub registration_method: ::prost::alloc::string::String,
}
/// 聊天创建事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatCreatedEvent {
    #[prost(string, tag = "1")]
    pub workspace_id: ::prost::alloc::string::String,
    /// single, group, channel
    #[prost(string, tag = "2")]
    pub chat_type: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub initial_members_count: i32,
}
/// 消息发送事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageSentEvent {
    #[prost(string, tag = "1")]
    pub chat_id: ::prost::alloc::string::String,
    /// text, file, image, etc.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub size: i32,
    #[prost(int32, tag = "4")]
    pub total_files: i32,
    #[prost(bool, tag = "5")]
    pub has_mentions: bool,
    #[prost(bool, tag = "6")]
    pub has_links: bool,
}
/// 加入聊天事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatJoinedEvent {
    #[prost(string, tag = "1")]
    pub chat_id: ::prost::alloc::string::String,
    /// invited, link, search
    #[prost(string, tag = "2")]
    pub join_method: ::prost::alloc::string::String,
}
/// 离开聊天事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatLeftEvent {
    #[prost(string, tag = "1")]
    pub chat_id: ::prost::alloc::string::String,
    /// voluntary, kicked, deleted
    #[prost(string, tag = "2")]
    pub leave_reason: ::prost::alloc::string::String,
}
/// 导航事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NavigationEvent {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub duration_ms: i32,
}
/// 文件上传事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileUploadedEvent {
    #[prost(string, tag = "1")]
    pub file_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub file_size: i64,
    /// drag_drop, button, paste
    #[prost(string, tag = "3")]
    pub upload_method: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub upload_duration_ms: i32,
}
/// 文件下载事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDownloadedEvent {
    #[prost(string, tag = "1")]
    pub file_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub file_size: i64,
    #[prost(int32, tag = "3")]
    pub download_duration_ms: i32,
}
/// 搜索事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchPerformedEvent {
    /// messages, users, files
    #[prost(string, tag = "1")]
    pub search_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query_length: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub results_count: i32,
    #[prost(int32, tag = "4")]
    pub search_duration_ms: i32,
    #[prost(bool, tag = "5")]
    pub has_filters: bool,
}
/// 通知事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationReceivedEvent {
    /// message, mention, system
    #[prost(string, tag = "1")]
    pub notification_type: ::prost::alloc::string::String,
    /// chat, system, user
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub was_clicked: bool,
}
/// 错误事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorOccurredEvent {
    #[prost(string, tag = "1")]
    pub error_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub stack_trace: ::prost::alloc::string::String,
    /// what user was doing
    #[prost(string, tag = "5")]
    pub context: ::prost::alloc::string::String,
}
/// 机器人响应事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotResponseEvent {
    #[prost(string, tag = "1")]
    pub bot_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chat_id: ::prost::alloc::string::String,
    /// ai_chat, command, auto_reply
    #[prost(string, tag = "3")]
    pub response_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub response_time_ms: u64,
    #[prost(uint32, tag = "5")]
    pub tokens_used: u32,
    #[prost(bool, tag = "6")]
    pub success: bool,
    /// if failed
    #[prost(string, tag = "7")]
    pub error_message: ::prost::alloc::string::String,
}
/// 记录事件请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordEventRequest {
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<EventContext>,
    #[prost(
        oneof = "record_event_request::EventType",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25"
    )]
    pub event_type: ::core::option::Option<record_event_request::EventType>,
}
/// Nested message and enum types in `RecordEventRequest`.
pub mod record_event_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EventType {
        #[prost(message, tag = "10")]
        AppStart(super::AppStartEvent),
        #[prost(message, tag = "11")]
        AppExit(super::AppExitEvent),
        #[prost(message, tag = "12")]
        UserLogin(super::UserLoginEvent),
        #[prost(message, tag = "13")]
        UserLogout(super::UserLogoutEvent),
        #[prost(message, tag = "14")]
        UserRegister(super::UserRegisterEvent),
        #[prost(message, tag = "15")]
        ChatCreated(super::ChatCreatedEvent),
        #[prost(message, tag = "16")]
        MessageSent(super::MessageSentEvent),
        #[prost(message, tag = "17")]
        ChatJoined(super::ChatJoinedEvent),
        #[prost(message, tag = "18")]
        ChatLeft(super::ChatLeftEvent),
        #[prost(message, tag = "19")]
        Navigation(super::NavigationEvent),
        #[prost(message, tag = "20")]
        FileUploaded(super::FileUploadedEvent),
        #[prost(message, tag = "21")]
        FileDownloaded(super::FileDownloadedEvent),
        #[prost(message, tag = "22")]
        SearchPerformed(super::SearchPerformedEvent),
        #[prost(message, tag = "23")]
        NotificationReceived(super::NotificationReceivedEvent),
        #[prost(message, tag = "24")]
        ErrorOccurred(super::ErrorOccurredEvent),
        #[prost(message, tag = "25")]
        BotResponse(super::BotResponseEvent),
    }
}
/// 批量记录事件请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchRecordEventsRequest {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<AnalyticsEvent>,
}
/// 获取分析数据请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsRequest {
    #[prost(string, tag = "1")]
    pub workspace_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag = "4")]
    pub event_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// hour, day, week, month
    #[prost(string, tag = "5")]
    pub granularity: ::prost::alloc::string::String,
}
/// 分析数据点
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyticsDataPoint {
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub event_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub count: i64,
    #[prost(map = "string, string", tag = "4")]
    pub dimensions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// 获取分析数据响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalyticsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_points: ::prost::alloc::vec::Vec<AnalyticsDataPoint>,
    #[prost(int64, tag = "2")]
    pub total_events: i64,
}
/// 获取用户活跃度请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserActivityRequest {
    #[prost(string, tag = "1")]
    pub workspace_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// 用户活跃度
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserActivity {
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub total_events: i64,
    #[prost(int64, tag = "3")]
    pub total_messages: i64,
    #[prost(int64, tag = "4")]
    pub total_sessions: i64,
    #[prost(int64, tag = "5")]
    pub total_time_ms: i64,
    #[prost(message, optional, tag = "6")]
    pub last_active: ::core::option::Option<::prost_types::Timestamp>,
}
/// 获取用户活跃度响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserActivityResponse {
    #[prost(message, repeated, tag = "1")]
    pub activities: ::prost::alloc::vec::Vec<UserActivity>,
    #[prost(int64, tag = "2")]
    pub total_active_users: i64,
}
/// Generated client implementations.
pub mod analytics_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 分析服务
    #[derive(Debug, Clone)]
    pub struct AnalyticsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AnalyticsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AnalyticsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AnalyticsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AnalyticsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 记录事件
        pub async fn record_event(
            &mut self,
            request: impl tonic::IntoRequest<super::RecordEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AnalyticsService/RecordEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.AnalyticsService", "RecordEvent"));
            self.inner.unary(req, path, codec).await
        }
        /// 批量记录事件
        pub async fn batch_record_events(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchRecordEventsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AnalyticsService/BatchRecordEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.AnalyticsService", "BatchRecordEvents"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取分析数据
        pub async fn get_analytics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnalyticsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAnalyticsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AnalyticsService/GetAnalytics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.AnalyticsService", "GetAnalytics"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取用户活跃度
        pub async fn get_user_activity(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUserActivityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AnalyticsService/GetUserActivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.AnalyticsService", "GetUserActivity"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod analytics_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AnalyticsServiceServer.
    #[async_trait]
    pub trait AnalyticsService: std::marker::Send + std::marker::Sync + 'static {
        /// 记录事件
        async fn record_event(
            &self,
            request: tonic::Request<super::RecordEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 批量记录事件
        async fn batch_record_events(
            &self,
            request: tonic::Request<super::BatchRecordEventsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 获取分析数据
        async fn get_analytics(
            &self,
            request: tonic::Request<super::GetAnalyticsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAnalyticsResponse>,
            tonic::Status,
        >;
        /// 获取用户活跃度
        async fn get_user_activity(
            &self,
            request: tonic::Request<super::GetUserActivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUserActivityResponse>,
            tonic::Status,
        >;
    }
    /// 分析服务
    #[derive(Debug)]
    pub struct AnalyticsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AnalyticsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AnalyticsServiceServer<T>
    where
        T: AnalyticsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.AnalyticsService/RecordEvent" => {
                    #[allow(non_camel_case_types)]
                    struct RecordEventSvc<T: AnalyticsService>(pub Arc<T>);
                    impl<
                        T: AnalyticsService,
                    > tonic::server::UnaryService<super::RecordEventRequest>
                    for RecordEventSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RecordEventRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AnalyticsService>::record_event(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RecordEventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.AnalyticsService/BatchRecordEvents" => {
                    #[allow(non_camel_case_types)]
                    struct BatchRecordEventsSvc<T: AnalyticsService>(pub Arc<T>);
                    impl<
                        T: AnalyticsService,
                    > tonic::server::UnaryService<super::BatchRecordEventsRequest>
                    for BatchRecordEventsSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchRecordEventsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AnalyticsService>::batch_record_events(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchRecordEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.AnalyticsService/GetAnalytics" => {
                    #[allow(non_camel_case_types)]
                    struct GetAnalyticsSvc<T: AnalyticsService>(pub Arc<T>);
                    impl<
                        T: AnalyticsService,
                    > tonic::server::UnaryService<super::GetAnalyticsRequest>
                    for GetAnalyticsSvc<T> {
                        type Response = super::GetAnalyticsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAnalyticsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AnalyticsService>::get_analytics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAnalyticsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.AnalyticsService/GetUserActivity" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserActivitySvc<T: AnalyticsService>(pub Arc<T>);
                    impl<
                        T: AnalyticsService,
                    > tonic::server::UnaryService<super::GetUserActivityRequest>
                    for GetUserActivitySvc<T> {
                        type Response = super::GetUserActivityResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUserActivityRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AnalyticsService>::get_user_activity(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUserActivitySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AnalyticsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.AnalyticsService";
    impl<T> tonic::server::NamedService for AnalyticsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// 注册请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterRequest {
    #[prost(string, tag = "1")]
    pub fullname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub workspace_id: i64,
}
/// 注册响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(string, tag = "2")]
    pub access_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub refresh_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<Error>,
}
/// 登录请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInRequest {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
/// 登录响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(string, tag = "2")]
    pub access_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub refresh_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<Error>,
}
/// 刷新令牌请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTokenRequest {
    #[prost(string, tag = "1")]
    pub refresh_token: ::prost::alloc::string::String,
}
/// 刷新令牌响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshTokenResponse {
    #[prost(string, tag = "1")]
    pub access_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub refresh_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 验证令牌请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyTokenRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// 验证令牌响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyTokenResponse {
    #[prost(bool, tag = "1")]
    pub valid: bool,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<User>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 获取用户请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetUserRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// 获取用户响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 更新用户请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(string, tag = "2")]
    pub fullname: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
    #[prost(enumeration = "UserStatus", tag = "4")]
    pub status: i32,
}
/// 更新用户响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 用户列表请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListUsersRequest {
    #[prost(int64, tag = "1")]
    pub workspace_id: i64,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<Pagination>,
}
/// 用户列表响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersResponse {
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<PaginatedResponse>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 搜索用户请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchUsersRequest {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub workspace_id: i64,
    #[prost(int32, tag = "3")]
    pub limit: i32,
}
/// 搜索用户响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchUsersResponse {
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// Generated client implementations.
pub mod auth_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 认证服务
    #[derive(Debug, Clone)]
    pub struct AuthServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AuthServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AuthServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AuthServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AuthServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 用户注册
        pub async fn register(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AuthService/Register",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.AuthService", "Register"));
            self.inner.unary(req, path, codec).await
        }
        /// 用户登录
        pub async fn sign_in(
            &mut self,
            request: impl tonic::IntoRequest<super::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::SignInResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AuthService/SignIn",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.AuthService", "SignIn"));
            self.inner.unary(req, path, codec).await
        }
        /// 用户登出
        pub async fn sign_out(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AuthService/SignOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.AuthService", "SignOut"));
            self.inner.unary(req, path, codec).await
        }
        /// 刷新 Token
        pub async fn refresh_token(
            &mut self,
            request: impl tonic::IntoRequest<super::RefreshTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RefreshTokenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AuthService/RefreshToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.AuthService", "RefreshToken"));
            self.inner.unary(req, path, codec).await
        }
        /// 验证 Token
        pub async fn verify_token(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifyTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifyTokenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.AuthService/VerifyToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.AuthService", "VerifyToken"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod user_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 用户管理服务
    #[derive(Debug, Clone)]
    pub struct UserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 获取用户信息
        pub async fn get_user(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.UserService/GetUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.UserService", "GetUser"));
            self.inner.unary(req, path, codec).await
        }
        /// 更新用户信息
        pub async fn update_user(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.UserService/UpdateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.UserService", "UpdateUser"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取用户列表
        pub async fn list_users(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUsersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.UserService/ListUsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.UserService", "ListUsers"));
            self.inner.unary(req, path, codec).await
        }
        /// 搜索用户
        pub async fn search_users(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchUsersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.UserService/SearchUsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.UserService", "SearchUsers"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod auth_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AuthServiceServer.
    #[async_trait]
    pub trait AuthService: std::marker::Send + std::marker::Sync + 'static {
        /// 用户注册
        async fn register(
            &self,
            request: tonic::Request<super::RegisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResponse>,
            tonic::Status,
        >;
        /// 用户登录
        async fn sign_in(
            &self,
            request: tonic::Request<super::SignInRequest>,
        ) -> std::result::Result<tonic::Response<super::SignInResponse>, tonic::Status>;
        /// 用户登出
        async fn sign_out(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 刷新 Token
        async fn refresh_token(
            &self,
            request: tonic::Request<super::RefreshTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RefreshTokenResponse>,
            tonic::Status,
        >;
        /// 验证 Token
        async fn verify_token(
            &self,
            request: tonic::Request<super::VerifyTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifyTokenResponse>,
            tonic::Status,
        >;
    }
    /// 认证服务
    #[derive(Debug)]
    pub struct AuthServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AuthServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AuthServiceServer<T>
    where
        T: AuthService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.AuthService/Register" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterSvc<T: AuthService>(pub Arc<T>);
                    impl<
                        T: AuthService,
                    > tonic::server::UnaryService<super::RegisterRequest>
                    for RegisterSvc<T> {
                        type Response = super::RegisterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AuthService>::register(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.AuthService/SignIn" => {
                    #[allow(non_camel_case_types)]
                    struct SignInSvc<T: AuthService>(pub Arc<T>);
                    impl<
                        T: AuthService,
                    > tonic::server::UnaryService<super::SignInRequest>
                    for SignInSvc<T> {
                        type Response = super::SignInResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignInRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AuthService>::sign_in(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignInSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.AuthService/SignOut" => {
                    #[allow(non_camel_case_types)]
                    struct SignOutSvc<T: AuthService>(pub Arc<T>);
                    impl<T: AuthService> tonic::server::UnaryService<()>
                    for SignOutSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AuthService>::sign_out(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignOutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.AuthService/RefreshToken" => {
                    #[allow(non_camel_case_types)]
                    struct RefreshTokenSvc<T: AuthService>(pub Arc<T>);
                    impl<
                        T: AuthService,
                    > tonic::server::UnaryService<super::RefreshTokenRequest>
                    for RefreshTokenSvc<T> {
                        type Response = super::RefreshTokenResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RefreshTokenRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AuthService>::refresh_token(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RefreshTokenSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.AuthService/VerifyToken" => {
                    #[allow(non_camel_case_types)]
                    struct VerifyTokenSvc<T: AuthService>(pub Arc<T>);
                    impl<
                        T: AuthService,
                    > tonic::server::UnaryService<super::VerifyTokenRequest>
                    for VerifyTokenSvc<T> {
                        type Response = super::VerifyTokenResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifyTokenRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AuthService>::verify_token(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifyTokenSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AuthServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.AuthService";
    impl<T> tonic::server::NamedService for AuthServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod user_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with UserServiceServer.
    #[async_trait]
    pub trait UserService: std::marker::Send + std::marker::Sync + 'static {
        /// 获取用户信息
        async fn get_user(
            &self,
            request: tonic::Request<super::GetUserRequest>,
        ) -> std::result::Result<tonic::Response<super::GetUserResponse>, tonic::Status>;
        /// 更新用户信息
        async fn update_user(
            &self,
            request: tonic::Request<super::UpdateUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateUserResponse>,
            tonic::Status,
        >;
        /// 获取用户列表
        async fn list_users(
            &self,
            request: tonic::Request<super::ListUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUsersResponse>,
            tonic::Status,
        >;
        /// 搜索用户
        async fn search_users(
            &self,
            request: tonic::Request<super::SearchUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchUsersResponse>,
            tonic::Status,
        >;
    }
    /// 用户管理服务
    #[derive(Debug)]
    pub struct UserServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> UserServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for UserServiceServer<T>
    where
        T: UserService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.UserService/GetUser" => {
                    #[allow(non_camel_case_types)]
                    struct GetUserSvc<T: UserService>(pub Arc<T>);
                    impl<
                        T: UserService,
                    > tonic::server::UnaryService<super::GetUserRequest>
                    for GetUserSvc<T> {
                        type Response = super::GetUserResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUserRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::get_user(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUserSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.UserService/UpdateUser" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateUserSvc<T: UserService>(pub Arc<T>);
                    impl<
                        T: UserService,
                    > tonic::server::UnaryService<super::UpdateUserRequest>
                    for UpdateUserSvc<T> {
                        type Response = super::UpdateUserResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateUserRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::update_user(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateUserSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.UserService/ListUsers" => {
                    #[allow(non_camel_case_types)]
                    struct ListUsersSvc<T: UserService>(pub Arc<T>);
                    impl<
                        T: UserService,
                    > tonic::server::UnaryService<super::ListUsersRequest>
                    for ListUsersSvc<T> {
                        type Response = super::ListUsersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListUsersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::list_users(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListUsersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.UserService/SearchUsers" => {
                    #[allow(non_camel_case_types)]
                    struct SearchUsersSvc<T: UserService>(pub Arc<T>);
                    impl<
                        T: UserService,
                    > tonic::server::UnaryService<super::SearchUsersRequest>
                    for SearchUsersSvc<T> {
                        type Response = super::SearchUsersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchUsersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::search_users(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchUsersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for UserServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.UserService";
    impl<T> tonic::server::NamedService for UserServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// 机器人配置
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "BotType", tag = "3")]
    pub r#type: i32,
    /// AI 模型名称
    #[prost(string, tag = "4")]
    pub model: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "6")]
    pub enabled: bool,
}
/// 机器人信息
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bot {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<BotConfig>,
    #[prost(int64, tag = "3")]
    pub creator_id: i64,
    #[prost(int64, tag = "4")]
    pub workspace_id: i64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 创建机器人请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBotRequest {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<BotConfig>,
    #[prost(int64, tag = "2")]
    pub workspace_id: i64,
}
/// 创建机器人响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBotResponse {
    #[prost(message, optional, tag = "1")]
    pub bot: ::core::option::Option<Bot>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 获取机器人请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBotRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// 获取机器人响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBotResponse {
    #[prost(message, optional, tag = "1")]
    pub bot: ::core::option::Option<Bot>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 更新机器人请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBotRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<BotConfig>,
}
/// 更新机器人响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBotResponse {
    #[prost(message, optional, tag = "1")]
    pub bot: ::core::option::Option<Bot>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 删除机器人请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteBotRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// 机器人列表请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListBotsRequest {
    #[prost(int64, tag = "1")]
    pub workspace_id: i64,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<Pagination>,
}
/// 机器人列表响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBotsResponse {
    #[prost(message, repeated, tag = "1")]
    pub bots: ::prost::alloc::vec::Vec<Bot>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<PaginatedResponse>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 查询机器人请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBotRequest {
    #[prost(int64, tag = "1")]
    pub bot_id: i64,
    #[prost(string, tag = "2")]
    pub question: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub chat_id: i64,
    #[prost(map = "string, string", tag = "4")]
    pub context: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// 查询机器人响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBotResponse {
    #[prost(string, tag = "1")]
    pub answer: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub sources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(float, tag = "3")]
    pub confidence: f32,
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<Error>,
}
/// 索引代码库请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexCodebaseRequest {
    #[prost(string, tag = "1")]
    pub repository_url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub branch: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub file_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// 索引代码库响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexCodebaseResponse {
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 搜索代码请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCodeRequest {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub file_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub limit: i32,
}
/// 代码搜索结果
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeSearchResult {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub start_line: i32,
    #[prost(int32, tag = "4")]
    pub end_line: i32,
    #[prost(float, tag = "5")]
    pub score: f32,
}
/// 搜索代码响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCodeResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<CodeSearchResult>,
    #[prost(int32, tag = "2")]
    pub total: i32,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 索引状态请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexStatusRequest {
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
}
/// 索引状态响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexStatusResponse {
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(enumeration = "IndexStatus", tag = "2")]
    pub status: i32,
    #[prost(int32, tag = "3")]
    pub progress: i32,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub error: ::core::option::Option<Error>,
}
/// 机器人类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BotType {
    Unspecified = 0,
    /// RAG 问答机器人
    Rag = 1,
    /// 代码助手
    CodeAssistant = 2,
    /// 自定义机器人
    Custom = 3,
}
impl BotType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BOT_TYPE_UNSPECIFIED",
            Self::Rag => "BOT_TYPE_RAG",
            Self::CodeAssistant => "BOT_TYPE_CODE_ASSISTANT",
            Self::Custom => "BOT_TYPE_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BOT_TYPE_RAG" => Some(Self::Rag),
            "BOT_TYPE_CODE_ASSISTANT" => Some(Self::CodeAssistant),
            "BOT_TYPE_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// 索引状态
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexStatus {
    Unspecified = 0,
    Pending = 1,
    Running = 2,
    Completed = 3,
    Failed = 4,
}
impl IndexStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEX_STATUS_UNSPECIFIED",
            Self::Pending => "INDEX_STATUS_PENDING",
            Self::Running => "INDEX_STATUS_RUNNING",
            Self::Completed => "INDEX_STATUS_COMPLETED",
            Self::Failed => "INDEX_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEX_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEX_STATUS_PENDING" => Some(Self::Pending),
            "INDEX_STATUS_RUNNING" => Some(Self::Running),
            "INDEX_STATUS_COMPLETED" => Some(Self::Completed),
            "INDEX_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod bot_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 机器人服务
    #[derive(Debug, Clone)]
    pub struct BotServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BotServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BotServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BotServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BotServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 创建机器人
        pub async fn create_bot(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBotResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.BotService/CreateBot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.BotService", "CreateBot"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取机器人信息
        pub async fn get_bot(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBotRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBotResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.BotService/GetBot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.BotService", "GetBot"));
            self.inner.unary(req, path, codec).await
        }
        /// 更新机器人配置
        pub async fn update_bot(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateBotResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.BotService/UpdateBot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.BotService", "UpdateBot"));
            self.inner.unary(req, path, codec).await
        }
        /// 删除机器人
        pub async fn delete_bot(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.BotService/DeleteBot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.BotService", "DeleteBot"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取机器人列表
        pub async fn list_bots(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBotsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.BotService/ListBots",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.BotService", "ListBots"));
            self.inner.unary(req, path, codec).await
        }
        /// 查询机器人
        pub async fn query_bot(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBotResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.BotService/QueryBot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.BotService", "QueryBot"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod code_index_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 代码索引服务
    #[derive(Debug, Clone)]
    pub struct CodeIndexServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CodeIndexServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CodeIndexServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CodeIndexServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CodeIndexServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 索引代码库
        pub async fn index_codebase(
            &mut self,
            request: impl tonic::IntoRequest<super::IndexCodebaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IndexCodebaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.CodeIndexService/IndexCodebase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.CodeIndexService", "IndexCodebase"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 搜索代码
        pub async fn search_code(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchCodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.CodeIndexService/SearchCode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.CodeIndexService", "SearchCode"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取索引状态
        pub async fn get_index_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIndexStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIndexStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.CodeIndexService/GetIndexStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.CodeIndexService", "GetIndexStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod bot_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BotServiceServer.
    #[async_trait]
    pub trait BotService: std::marker::Send + std::marker::Sync + 'static {
        /// 创建机器人
        async fn create_bot(
            &self,
            request: tonic::Request<super::CreateBotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBotResponse>,
            tonic::Status,
        >;
        /// 获取机器人信息
        async fn get_bot(
            &self,
            request: tonic::Request<super::GetBotRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBotResponse>, tonic::Status>;
        /// 更新机器人配置
        async fn update_bot(
            &self,
            request: tonic::Request<super::UpdateBotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateBotResponse>,
            tonic::Status,
        >;
        /// 删除机器人
        async fn delete_bot(
            &self,
            request: tonic::Request<super::DeleteBotRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 获取机器人列表
        async fn list_bots(
            &self,
            request: tonic::Request<super::ListBotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBotsResponse>,
            tonic::Status,
        >;
        /// 查询机器人
        async fn query_bot(
            &self,
            request: tonic::Request<super::QueryBotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBotResponse>,
            tonic::Status,
        >;
    }
    /// 机器人服务
    #[derive(Debug)]
    pub struct BotServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BotServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BotServiceServer<T>
    where
        T: BotService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.BotService/CreateBot" => {
                    #[allow(non_camel_case_types)]
                    struct CreateBotSvc<T: BotService>(pub Arc<T>);
                    impl<
                        T: BotService,
                    > tonic::server::UnaryService<super::CreateBotRequest>
                    for CreateBotSvc<T> {
                        type Response = super::CreateBotResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateBotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BotService>::create_bot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateBotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.BotService/GetBot" => {
                    #[allow(non_camel_case_types)]
                    struct GetBotSvc<T: BotService>(pub Arc<T>);
                    impl<T: BotService> tonic::server::UnaryService<super::GetBotRequest>
                    for GetBotSvc<T> {
                        type Response = super::GetBotResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BotService>::get_bot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.BotService/UpdateBot" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateBotSvc<T: BotService>(pub Arc<T>);
                    impl<
                        T: BotService,
                    > tonic::server::UnaryService<super::UpdateBotRequest>
                    for UpdateBotSvc<T> {
                        type Response = super::UpdateBotResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateBotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BotService>::update_bot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateBotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.BotService/DeleteBot" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteBotSvc<T: BotService>(pub Arc<T>);
                    impl<
                        T: BotService,
                    > tonic::server::UnaryService<super::DeleteBotRequest>
                    for DeleteBotSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteBotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BotService>::delete_bot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteBotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.BotService/ListBots" => {
                    #[allow(non_camel_case_types)]
                    struct ListBotsSvc<T: BotService>(pub Arc<T>);
                    impl<
                        T: BotService,
                    > tonic::server::UnaryService<super::ListBotsRequest>
                    for ListBotsSvc<T> {
                        type Response = super::ListBotsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBotsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BotService>::list_bots(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBotsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.BotService/QueryBot" => {
                    #[allow(non_camel_case_types)]
                    struct QueryBotSvc<T: BotService>(pub Arc<T>);
                    impl<
                        T: BotService,
                    > tonic::server::UnaryService<super::QueryBotRequest>
                    for QueryBotSvc<T> {
                        type Response = super::QueryBotResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryBotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BotService>::query_bot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryBotSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BotServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.BotService";
    impl<T> tonic::server::NamedService for BotServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod code_index_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CodeIndexServiceServer.
    #[async_trait]
    pub trait CodeIndexService: std::marker::Send + std::marker::Sync + 'static {
        /// 索引代码库
        async fn index_codebase(
            &self,
            request: tonic::Request<super::IndexCodebaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IndexCodebaseResponse>,
            tonic::Status,
        >;
        /// 搜索代码
        async fn search_code(
            &self,
            request: tonic::Request<super::SearchCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchCodeResponse>,
            tonic::Status,
        >;
        /// 获取索引状态
        async fn get_index_status(
            &self,
            request: tonic::Request<super::GetIndexStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIndexStatusResponse>,
            tonic::Status,
        >;
    }
    /// 代码索引服务
    #[derive(Debug)]
    pub struct CodeIndexServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CodeIndexServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CodeIndexServiceServer<T>
    where
        T: CodeIndexService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.CodeIndexService/IndexCodebase" => {
                    #[allow(non_camel_case_types)]
                    struct IndexCodebaseSvc<T: CodeIndexService>(pub Arc<T>);
                    impl<
                        T: CodeIndexService,
                    > tonic::server::UnaryService<super::IndexCodebaseRequest>
                    for IndexCodebaseSvc<T> {
                        type Response = super::IndexCodebaseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::IndexCodebaseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CodeIndexService>::index_codebase(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = IndexCodebaseSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.CodeIndexService/SearchCode" => {
                    #[allow(non_camel_case_types)]
                    struct SearchCodeSvc<T: CodeIndexService>(pub Arc<T>);
                    impl<
                        T: CodeIndexService,
                    > tonic::server::UnaryService<super::SearchCodeRequest>
                    for SearchCodeSvc<T> {
                        type Response = super::SearchCodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchCodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CodeIndexService>::search_code(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchCodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.CodeIndexService/GetIndexStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetIndexStatusSvc<T: CodeIndexService>(pub Arc<T>);
                    impl<
                        T: CodeIndexService,
                    > tonic::server::UnaryService<super::GetIndexStatusRequest>
                    for GetIndexStatusSvc<T> {
                        type Response = super::GetIndexStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetIndexStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CodeIndexService>::get_index_status(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetIndexStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CodeIndexServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.CodeIndexService";
    impl<T> tonic::server::NamedService for CodeIndexServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// 消息事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageEvent {
    #[prost(oneof = "message_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<message_event::Event>,
}
/// Nested message and enum types in `MessageEvent`.
pub mod message_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        NewMessage(super::Message),
        #[prost(message, tag = "2")]
        MessageUpdate(super::MessageUpdate),
        #[prost(message, tag = "3")]
        MessageDelete(super::MessageDelete),
        #[prost(message, tag = "4")]
        TypingIndicator(super::TypingIndicator),
        #[prost(message, tag = "5")]
        ReadReceipt(super::ReadReceipt),
    }
}
/// 消息更新事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageUpdate {
    #[prost(int64, tag = "1")]
    pub message_id: i64,
    #[prost(string, tag = "2")]
    pub new_content: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 消息删除事件
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MessageDelete {
    #[prost(int64, tag = "1")]
    pub message_id: i64,
    #[prost(message, optional, tag = "2")]
    pub deleted_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 输入指示器
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TypingIndicator {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
    #[prost(bool, tag = "3")]
    pub is_typing: bool,
}
/// 已读回执
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadReceipt {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
    #[prost(int64, tag = "3")]
    pub last_read_message_id: i64,
    #[prost(message, optional, tag = "4")]
    pub read_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 创建聊天请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChatRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "ChatType", tag = "2")]
    pub r#type: i32,
    #[prost(int64, tag = "3")]
    pub workspace_id: i64,
    #[prost(int64, repeated, tag = "4")]
    pub members: ::prost::alloc::vec::Vec<i64>,
}
/// 创建聊天响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChatResponse {
    #[prost(message, optional, tag = "1")]
    pub chat: ::core::option::Option<Chat>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 获取聊天请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetChatRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// 获取聊天响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChatResponse {
    #[prost(message, optional, tag = "1")]
    pub chat: ::core::option::Option<Chat>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 聊天列表请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListChatsRequest {
    #[prost(int64, tag = "1")]
    pub workspace_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<Pagination>,
}
/// 聊天列表响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub chats: ::prost::alloc::vec::Vec<Chat>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<PaginatedResponse>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 更新聊天请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateChatRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, repeated, tag = "3")]
    pub members: ::prost::alloc::vec::Vec<i64>,
}
/// 更新聊天响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateChatResponse {
    #[prost(message, optional, tag = "1")]
    pub chat: ::core::option::Option<Chat>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 删除聊天请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteChatRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// 加入聊天请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JoinChatRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
}
/// 离开聊天请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeaveChatRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
}
/// 发送消息请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub idempotency_key: ::prost::alloc::string::String,
}
/// 发送消息响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageResponse {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 获取消息请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMessageRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// 获取消息响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMessageResponse {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 消息列表请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListMessagesRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(message, optional, tag = "2")]
    pub since: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub until: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub pagination: ::core::option::Option<Pagination>,
}
/// 消息列表响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMessagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<PaginatedResponse>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 更新消息请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMessageRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
/// 更新消息响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMessageResponse {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<Message>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 删除消息请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteMessageRequest {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// 标记已读请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarkAsReadRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(int64, tag = "2")]
    pub message_id: i64,
    #[prost(int64, tag = "3")]
    pub user_id: i64,
}
/// 批量标记已读请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMarkAsReadRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(int64, repeated, tag = "2")]
    pub message_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(int64, tag = "3")]
    pub user_id: i64,
}
/// 消息流请求
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamMessagesRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(message, optional, tag = "2")]
    pub since: ::core::option::Option<::prost_types::Timestamp>,
}
/// 批量发送消息请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchSendMessagesRequest {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<SendMessageRequest>,
}
/// 批量发送消息响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchSendMessagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<SendMessageResponse>,
    #[prost(int32, tag = "2")]
    pub success_count: i32,
    #[prost(int32, tag = "3")]
    pub failure_count: i32,
}
/// Generated client implementations.
pub mod chat_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 聊天服务
    #[derive(Debug, Clone)]
    pub struct ChatServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ChatServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ChatServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ChatServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ChatServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 创建聊天
        pub async fn create_chat(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateChatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateChatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.ChatService/CreateChat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.ChatService", "CreateChat"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取聊天信息
        pub async fn get_chat(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetChatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.ChatService/GetChat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.ChatService", "GetChat"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取聊天列表
        pub async fn list_chats(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.ChatService/ListChats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.ChatService", "ListChats"));
            self.inner.unary(req, path, codec).await
        }
        /// 更新聊天信息
        pub async fn update_chat(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateChatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateChatResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.ChatService/UpdateChat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.ChatService", "UpdateChat"));
            self.inner.unary(req, path, codec).await
        }
        /// 删除聊天
        pub async fn delete_chat(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteChatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.ChatService/DeleteChat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.ChatService", "DeleteChat"));
            self.inner.unary(req, path, codec).await
        }
        /// 加入聊天
        pub async fn join_chat(
            &mut self,
            request: impl tonic::IntoRequest<super::JoinChatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.ChatService/JoinChat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.ChatService", "JoinChat"));
            self.inner.unary(req, path, codec).await
        }
        /// 离开聊天
        pub async fn leave_chat(
            &mut self,
            request: impl tonic::IntoRequest<super::LeaveChatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.ChatService/LeaveChat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.ChatService", "LeaveChat"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod message_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 消息服务
    #[derive(Debug, Clone)]
    pub struct MessageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MessageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MessageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MessageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MessageServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 发送消息
        pub async fn send_message(
            &mut self,
            request: impl tonic::IntoRequest<super::SendMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SendMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageService/SendMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.MessageService", "SendMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取消息
        pub async fn get_message(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageService/GetMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.MessageService", "GetMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取消息列表
        pub async fn list_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageService/ListMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.MessageService", "ListMessages"));
            self.inner.unary(req, path, codec).await
        }
        /// 更新消息
        pub async fn update_message(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageService/UpdateMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.MessageService", "UpdateMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// 删除消息
        pub async fn delete_message(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMessageRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageService/DeleteMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.MessageService", "DeleteMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// 标记消息为已读
        pub async fn mark_as_read(
            &mut self,
            request: impl tonic::IntoRequest<super::MarkAsReadRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageService/MarkAsRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.MessageService", "MarkAsRead"));
            self.inner.unary(req, path, codec).await
        }
        /// 批量标记消息为已读
        pub async fn batch_mark_as_read(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchMarkAsReadRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageService/BatchMarkAsRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.MessageService", "BatchMarkAsRead"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod message_stream_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 消息流服务
    #[derive(Debug, Clone)]
    pub struct MessageStreamServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MessageStreamServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MessageStreamServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MessageStreamServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MessageStreamServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 实时消息流
        pub async fn stream_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::MessageEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageStreamService/StreamMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "fechatter.v1.MessageStreamService",
                        "StreamMessages",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 批量发送消息
        pub async fn batch_send_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchSendMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchSendMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.MessageStreamService/BatchSendMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "fechatter.v1.MessageStreamService",
                        "BatchSendMessages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod chat_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ChatServiceServer.
    #[async_trait]
    pub trait ChatService: std::marker::Send + std::marker::Sync + 'static {
        /// 创建聊天
        async fn create_chat(
            &self,
            request: tonic::Request<super::CreateChatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateChatResponse>,
            tonic::Status,
        >;
        /// 获取聊天信息
        async fn get_chat(
            &self,
            request: tonic::Request<super::GetChatRequest>,
        ) -> std::result::Result<tonic::Response<super::GetChatResponse>, tonic::Status>;
        /// 获取聊天列表
        async fn list_chats(
            &self,
            request: tonic::Request<super::ListChatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChatsResponse>,
            tonic::Status,
        >;
        /// 更新聊天信息
        async fn update_chat(
            &self,
            request: tonic::Request<super::UpdateChatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateChatResponse>,
            tonic::Status,
        >;
        /// 删除聊天
        async fn delete_chat(
            &self,
            request: tonic::Request<super::DeleteChatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 加入聊天
        async fn join_chat(
            &self,
            request: tonic::Request<super::JoinChatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 离开聊天
        async fn leave_chat(
            &self,
            request: tonic::Request<super::LeaveChatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
    }
    /// 聊天服务
    #[derive(Debug)]
    pub struct ChatServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ChatServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ChatServiceServer<T>
    where
        T: ChatService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.ChatService/CreateChat" => {
                    #[allow(non_camel_case_types)]
                    struct CreateChatSvc<T: ChatService>(pub Arc<T>);
                    impl<
                        T: ChatService,
                    > tonic::server::UnaryService<super::CreateChatRequest>
                    for CreateChatSvc<T> {
                        type Response = super::CreateChatResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateChatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChatService>::create_chat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateChatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.ChatService/GetChat" => {
                    #[allow(non_camel_case_types)]
                    struct GetChatSvc<T: ChatService>(pub Arc<T>);
                    impl<
                        T: ChatService,
                    > tonic::server::UnaryService<super::GetChatRequest>
                    for GetChatSvc<T> {
                        type Response = super::GetChatResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetChatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChatService>::get_chat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetChatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.ChatService/ListChats" => {
                    #[allow(non_camel_case_types)]
                    struct ListChatsSvc<T: ChatService>(pub Arc<T>);
                    impl<
                        T: ChatService,
                    > tonic::server::UnaryService<super::ListChatsRequest>
                    for ListChatsSvc<T> {
                        type Response = super::ListChatsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListChatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChatService>::list_chats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListChatsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.ChatService/UpdateChat" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateChatSvc<T: ChatService>(pub Arc<T>);
                    impl<
                        T: ChatService,
                    > tonic::server::UnaryService<super::UpdateChatRequest>
                    for UpdateChatSvc<T> {
                        type Response = super::UpdateChatResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateChatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChatService>::update_chat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateChatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.ChatService/DeleteChat" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteChatSvc<T: ChatService>(pub Arc<T>);
                    impl<
                        T: ChatService,
                    > tonic::server::UnaryService<super::DeleteChatRequest>
                    for DeleteChatSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteChatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChatService>::delete_chat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteChatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.ChatService/JoinChat" => {
                    #[allow(non_camel_case_types)]
                    struct JoinChatSvc<T: ChatService>(pub Arc<T>);
                    impl<
                        T: ChatService,
                    > tonic::server::UnaryService<super::JoinChatRequest>
                    for JoinChatSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::JoinChatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChatService>::join_chat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = JoinChatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.ChatService/LeaveChat" => {
                    #[allow(non_camel_case_types)]
                    struct LeaveChatSvc<T: ChatService>(pub Arc<T>);
                    impl<
                        T: ChatService,
                    > tonic::server::UnaryService<super::LeaveChatRequest>
                    for LeaveChatSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LeaveChatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ChatService>::leave_chat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LeaveChatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ChatServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.ChatService";
    impl<T> tonic::server::NamedService for ChatServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod message_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MessageServiceServer.
    #[async_trait]
    pub trait MessageService: std::marker::Send + std::marker::Sync + 'static {
        /// 发送消息
        async fn send_message(
            &self,
            request: tonic::Request<super::SendMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SendMessageResponse>,
            tonic::Status,
        >;
        /// 获取消息
        async fn get_message(
            &self,
            request: tonic::Request<super::GetMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMessageResponse>,
            tonic::Status,
        >;
        /// 获取消息列表
        async fn list_messages(
            &self,
            request: tonic::Request<super::ListMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMessagesResponse>,
            tonic::Status,
        >;
        /// 更新消息
        async fn update_message(
            &self,
            request: tonic::Request<super::UpdateMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateMessageResponse>,
            tonic::Status,
        >;
        /// 删除消息
        async fn delete_message(
            &self,
            request: tonic::Request<super::DeleteMessageRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 标记消息为已读
        async fn mark_as_read(
            &self,
            request: tonic::Request<super::MarkAsReadRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 批量标记消息为已读
        async fn batch_mark_as_read(
            &self,
            request: tonic::Request<super::BatchMarkAsReadRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
    }
    /// 消息服务
    #[derive(Debug)]
    pub struct MessageServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MessageServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MessageServiceServer<T>
    where
        T: MessageService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.MessageService/SendMessage" => {
                    #[allow(non_camel_case_types)]
                    struct SendMessageSvc<T: MessageService>(pub Arc<T>);
                    impl<
                        T: MessageService,
                    > tonic::server::UnaryService<super::SendMessageRequest>
                    for SendMessageSvc<T> {
                        type Response = super::SendMessageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SendMessageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageService>::send_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SendMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.MessageService/GetMessage" => {
                    #[allow(non_camel_case_types)]
                    struct GetMessageSvc<T: MessageService>(pub Arc<T>);
                    impl<
                        T: MessageService,
                    > tonic::server::UnaryService<super::GetMessageRequest>
                    for GetMessageSvc<T> {
                        type Response = super::GetMessageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMessageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageService>::get_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.MessageService/ListMessages" => {
                    #[allow(non_camel_case_types)]
                    struct ListMessagesSvc<T: MessageService>(pub Arc<T>);
                    impl<
                        T: MessageService,
                    > tonic::server::UnaryService<super::ListMessagesRequest>
                    for ListMessagesSvc<T> {
                        type Response = super::ListMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageService>::list_messages(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.MessageService/UpdateMessage" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateMessageSvc<T: MessageService>(pub Arc<T>);
                    impl<
                        T: MessageService,
                    > tonic::server::UnaryService<super::UpdateMessageRequest>
                    for UpdateMessageSvc<T> {
                        type Response = super::UpdateMessageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateMessageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageService>::update_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.MessageService/DeleteMessage" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteMessageSvc<T: MessageService>(pub Arc<T>);
                    impl<
                        T: MessageService,
                    > tonic::server::UnaryService<super::DeleteMessageRequest>
                    for DeleteMessageSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteMessageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageService>::delete_message(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.MessageService/MarkAsRead" => {
                    #[allow(non_camel_case_types)]
                    struct MarkAsReadSvc<T: MessageService>(pub Arc<T>);
                    impl<
                        T: MessageService,
                    > tonic::server::UnaryService<super::MarkAsReadRequest>
                    for MarkAsReadSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MarkAsReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageService>::mark_as_read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarkAsReadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.MessageService/BatchMarkAsRead" => {
                    #[allow(non_camel_case_types)]
                    struct BatchMarkAsReadSvc<T: MessageService>(pub Arc<T>);
                    impl<
                        T: MessageService,
                    > tonic::server::UnaryService<super::BatchMarkAsReadRequest>
                    for BatchMarkAsReadSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchMarkAsReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageService>::batch_mark_as_read(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchMarkAsReadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MessageServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.MessageService";
    impl<T> tonic::server::NamedService for MessageServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod message_stream_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MessageStreamServiceServer.
    #[async_trait]
    pub trait MessageStreamService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the StreamMessages method.
        type StreamMessagesStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::MessageEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// 实时消息流
        async fn stream_messages(
            &self,
            request: tonic::Request<super::StreamMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamMessagesStream>,
            tonic::Status,
        >;
        /// 批量发送消息
        async fn batch_send_messages(
            &self,
            request: tonic::Request<super::BatchSendMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchSendMessagesResponse>,
            tonic::Status,
        >;
    }
    /// 消息流服务
    #[derive(Debug)]
    pub struct MessageStreamServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MessageStreamServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for MessageStreamServiceServer<T>
    where
        T: MessageStreamService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.MessageStreamService/StreamMessages" => {
                    #[allow(non_camel_case_types)]
                    struct StreamMessagesSvc<T: MessageStreamService>(pub Arc<T>);
                    impl<
                        T: MessageStreamService,
                    > tonic::server::ServerStreamingService<super::StreamMessagesRequest>
                    for StreamMessagesSvc<T> {
                        type Response = super::MessageEvent;
                        type ResponseStream = T::StreamMessagesStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StreamMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageStreamService>::stream_messages(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.MessageStreamService/BatchSendMessages" => {
                    #[allow(non_camel_case_types)]
                    struct BatchSendMessagesSvc<T: MessageStreamService>(pub Arc<T>);
                    impl<
                        T: MessageStreamService,
                    > tonic::server::UnaryService<super::BatchSendMessagesRequest>
                    for BatchSendMessagesSvc<T> {
                        type Response = super::BatchSendMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchSendMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MessageStreamService>::batch_send_messages(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchSendMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MessageStreamServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.MessageStreamService";
    impl<T> tonic::server::NamedService for MessageStreamServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// 上传文件请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadFileRequest {
    #[prost(oneof = "upload_file_request::Data", tags = "1, 2")]
    pub data: ::core::option::Option<upload_file_request::Data>,
}
/// Nested message and enum types in `UploadFileRequest`.
pub mod upload_file_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        Metadata(super::FileMetadata),
        #[prost(message, tag = "2")]
        Chunk(super::FileChunk),
    }
}
/// 文件元数据
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileMetadata {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub size: i64,
    #[prost(int64, tag = "4")]
    pub chat_id: i64,
    #[prost(string, tag = "5")]
    pub checksum: ::prost::alloc::string::String,
}
/// 文件块
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileChunk {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, tag = "2")]
    pub chunk_number: i32,
    #[prost(bool, tag = "3")]
    pub is_last: bool,
}
/// 上传文件响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadFileResponse {
    #[prost(string, tag = "1")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub size: i64,
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<Error>,
}
/// 下载文件请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadFileRequest {
    #[prost(string, tag = "1")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub offset: i64,
    #[prost(int64, tag = "3")]
    pub limit: i64,
}
/// 下载文件响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadFileResponse {
    #[prost(oneof = "download_file_response::Data", tags = "1, 2, 3")]
    pub data: ::core::option::Option<download_file_response::Data>,
}
/// Nested message and enum types in `DownloadFileResponse`.
pub mod download_file_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        FileInfo(super::FileInfo),
        #[prost(message, tag = "2")]
        Chunk(super::FileChunk),
        #[prost(message, tag = "3")]
        Error(super::Error),
    }
}
/// 获取文件信息请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileInfoRequest {
    #[prost(string, tag = "1")]
    pub file_id: ::prost::alloc::string::String,
}
/// 获取文件信息响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub file_info: ::core::option::Option<FileInfo>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<Error>,
}
/// 删除文件请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFileRequest {
    #[prost(string, tag = "1")]
    pub file_id: ::prost::alloc::string::String,
}
/// 文件列表请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesRequest {
    #[prost(int64, tag = "1")]
    pub chat_id: i64,
    #[prost(string, tag = "2")]
    pub content_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<Pagination>,
}
/// 文件列表响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<FileInfo>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<PaginatedResponse>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// Generated client implementations.
pub mod file_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 文件服务
    #[derive(Debug, Clone)]
    pub struct FileServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FileServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FileServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FileServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FileServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 上传文件
        pub async fn upload_file(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::UploadFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UploadFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.FileService/UploadFile",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.FileService", "UploadFile"));
            self.inner.client_streaming(req, path, codec).await
        }
        /// 下载文件
        pub async fn download_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DownloadFileRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DownloadFileResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.FileService/DownloadFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.FileService", "DownloadFile"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// 获取文件信息
        pub async fn get_file_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFileInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFileInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.FileService/GetFileInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.FileService", "GetFileInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// 删除文件
        pub async fn delete_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.FileService/DeleteFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.FileService", "DeleteFile"));
            self.inner.unary(req, path, codec).await
        }
        /// 获取文件列表
        pub async fn list_files(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFilesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.FileService/ListFiles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("fechatter.v1.FileService", "ListFiles"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod file_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FileServiceServer.
    #[async_trait]
    pub trait FileService: std::marker::Send + std::marker::Sync + 'static {
        /// 上传文件
        async fn upload_file(
            &self,
            request: tonic::Request<tonic::Streaming<super::UploadFileRequest>>,
        ) -> std::result::Result<
            tonic::Response<super::UploadFileResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the DownloadFile method.
        type DownloadFileStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DownloadFileResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// 下载文件
        async fn download_file(
            &self,
            request: tonic::Request<super::DownloadFileRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::DownloadFileStream>,
            tonic::Status,
        >;
        /// 获取文件信息
        async fn get_file_info(
            &self,
            request: tonic::Request<super::GetFileInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFileInfoResponse>,
            tonic::Status,
        >;
        /// 删除文件
        async fn delete_file(
            &self,
            request: tonic::Request<super::DeleteFileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 获取文件列表
        async fn list_files(
            &self,
            request: tonic::Request<super::ListFilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFilesResponse>,
            tonic::Status,
        >;
    }
    /// 文件服务
    #[derive(Debug)]
    pub struct FileServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FileServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for FileServiceServer<T>
    where
        T: FileService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.FileService/UploadFile" => {
                    #[allow(non_camel_case_types)]
                    struct UploadFileSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::ClientStreamingService<super::UploadFileRequest>
                    for UploadFileSvc<T> {
                        type Response = super::UploadFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::UploadFileRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::upload_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.FileService/DownloadFile" => {
                    #[allow(non_camel_case_types)]
                    struct DownloadFileSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::ServerStreamingService<super::DownloadFileRequest>
                    for DownloadFileSvc<T> {
                        type Response = super::DownloadFileResponse;
                        type ResponseStream = T::DownloadFileStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DownloadFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::download_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DownloadFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.FileService/GetFileInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetFileInfoSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::GetFileInfoRequest>
                    for GetFileInfoSvc<T> {
                        type Response = super::GetFileInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFileInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::get_file_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFileInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.FileService/DeleteFile" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteFileSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::DeleteFileRequest>
                    for DeleteFileSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::delete_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.FileService/ListFiles" => {
                    #[allow(non_camel_case_types)]
                    struct ListFilesSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::ListFilesRequest>
                    for ListFilesSvc<T> {
                        type Response = super::ListFilesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListFilesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::list_files(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListFilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FileServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.FileService";
    impl<T> tonic::server::NamedService for FileServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// 通知事件
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "NotificationType", tag = "2")]
    pub r#type: i32,
    #[prost(int64, tag = "3")]
    pub user_id: i64,
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub content: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "6")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "7")]
    pub read: bool,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// 订阅请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRequest {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(enumeration = "NotificationType", repeated, tag = "2")]
    pub types: ::prost::alloc::vec::Vec<i32>,
}
/// 发送通知请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendNotificationRequest {
    #[prost(enumeration = "NotificationType", tag = "1")]
    pub r#type: i32,
    #[prost(int64, repeated, tag = "2")]
    pub user_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// 标记通知已读请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkNotificationAsReadRequest {
    #[prost(string, tag = "1")]
    pub notification_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub user_id: i64,
}
/// 获取通知请求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotificationsRequest {
    #[prost(int64, tag = "1")]
    pub user_id: i64,
    #[prost(enumeration = "NotificationType", repeated, tag = "2")]
    pub types: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "3")]
    pub unread_only: bool,
    #[prost(message, optional, tag = "4")]
    pub pagination: ::core::option::Option<Pagination>,
}
/// 获取通知响应
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotificationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub notifications: ::prost::alloc::vec::Vec<NotificationEvent>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<PaginatedResponse>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
}
/// 通知类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotificationType {
    Unspecified = 0,
    /// 新消息
    Message = 1,
    /// 被提及
    Mention = 2,
    /// 聊天邀请
    ChatInvite = 3,
    /// 系统通知
    System = 4,
    /// 机器人回复
    BotReply = 5,
}
impl NotificationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NOTIFICATION_TYPE_UNSPECIFIED",
            Self::Message => "NOTIFICATION_TYPE_MESSAGE",
            Self::Mention => "NOTIFICATION_TYPE_MENTION",
            Self::ChatInvite => "NOTIFICATION_TYPE_CHAT_INVITE",
            Self::System => "NOTIFICATION_TYPE_SYSTEM",
            Self::BotReply => "NOTIFICATION_TYPE_BOT_REPLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOTIFICATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NOTIFICATION_TYPE_MESSAGE" => Some(Self::Message),
            "NOTIFICATION_TYPE_MENTION" => Some(Self::Mention),
            "NOTIFICATION_TYPE_CHAT_INVITE" => Some(Self::ChatInvite),
            "NOTIFICATION_TYPE_SYSTEM" => Some(Self::System),
            "NOTIFICATION_TYPE_BOT_REPLY" => Some(Self::BotReply),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod notification_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// 通知服务
    #[derive(Debug, Clone)]
    pub struct NotificationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NotificationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NotificationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NotificationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            NotificationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// 订阅通知流
        pub async fn subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::NotificationEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.NotificationService/Subscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.NotificationService", "Subscribe"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// 发送通知
        pub async fn send_notification(
            &mut self,
            request: impl tonic::IntoRequest<super::SendNotificationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.NotificationService/SendNotification",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "fechatter.v1.NotificationService",
                        "SendNotification",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 标记通知为已读
        pub async fn mark_as_read(
            &mut self,
            request: impl tonic::IntoRequest<super::MarkNotificationAsReadRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.NotificationService/MarkAsRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("fechatter.v1.NotificationService", "MarkAsRead"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// 获取通知历史
        pub async fn get_notifications(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNotificationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNotificationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/fechatter.v1.NotificationService/GetNotifications",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "fechatter.v1.NotificationService",
                        "GetNotifications",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod notification_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with NotificationServiceServer.
    #[async_trait]
    pub trait NotificationService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the Subscribe method.
        type SubscribeStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::NotificationEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// 订阅通知流
        async fn subscribe(
            &self,
            request: tonic::Request<super::SubscribeRequest>,
        ) -> std::result::Result<tonic::Response<Self::SubscribeStream>, tonic::Status>;
        /// 发送通知
        async fn send_notification(
            &self,
            request: tonic::Request<super::SendNotificationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 标记通知为已读
        async fn mark_as_read(
            &self,
            request: tonic::Request<super::MarkNotificationAsReadRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// 获取通知历史
        async fn get_notifications(
            &self,
            request: tonic::Request<super::GetNotificationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNotificationsResponse>,
            tonic::Status,
        >;
    }
    /// 通知服务
    #[derive(Debug)]
    pub struct NotificationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> NotificationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for NotificationServiceServer<T>
    where
        T: NotificationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/fechatter.v1.NotificationService/Subscribe" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeSvc<T: NotificationService>(pub Arc<T>);
                    impl<
                        T: NotificationService,
                    > tonic::server::ServerStreamingService<super::SubscribeRequest>
                    for SubscribeSvc<T> {
                        type Response = super::NotificationEvent;
                        type ResponseStream = T::SubscribeStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NotificationService>::subscribe(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.NotificationService/SendNotification" => {
                    #[allow(non_camel_case_types)]
                    struct SendNotificationSvc<T: NotificationService>(pub Arc<T>);
                    impl<
                        T: NotificationService,
                    > tonic::server::UnaryService<super::SendNotificationRequest>
                    for SendNotificationSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SendNotificationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NotificationService>::send_notification(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SendNotificationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.NotificationService/MarkAsRead" => {
                    #[allow(non_camel_case_types)]
                    struct MarkAsReadSvc<T: NotificationService>(pub Arc<T>);
                    impl<
                        T: NotificationService,
                    > tonic::server::UnaryService<super::MarkNotificationAsReadRequest>
                    for MarkAsReadSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MarkNotificationAsReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NotificationService>::mark_as_read(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MarkAsReadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/fechatter.v1.NotificationService/GetNotifications" => {
                    #[allow(non_camel_case_types)]
                    struct GetNotificationsSvc<T: NotificationService>(pub Arc<T>);
                    impl<
                        T: NotificationService,
                    > tonic::server::UnaryService<super::GetNotificationsRequest>
                    for GetNotificationsSvc<T> {
                        type Response = super::GetNotificationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNotificationsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as NotificationService>::get_notifications(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNotificationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for NotificationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "fechatter.v1.NotificationService";
    impl<T> tonic::server::NamedService for NotificationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
